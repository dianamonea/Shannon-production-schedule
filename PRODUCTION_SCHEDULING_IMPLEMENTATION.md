# 生产调度多智能体系统 - 会话接入后端与三智能体协同

## 概述

本文档描述了Shannon多智能体框架中生产调度系统的完整实现，包括：

- ✅ 会话（Session）接入后端
- ✅ 三个具身智能体的顺序执行
- ✅ 智能体之间的协同过程展示
- ✅ 完整的协同日志和时间线追踪

## 系统架构

### 三类具身智能体

```
┌─────────────────────────────────────────────────────────┐
│           生产调度多智能体系统                              │
├─────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────────┐                                      │
│  │ 【机床智能体】   │                                      │
│  │  MachineToolAgent│  - 零件优先级排序                    │
│  │                  │  - 工序能力匹配                      │
│  │  输出：排产方案  │  - 主轴利用率计算                    │
│  └────────┬─────────┘  - 瓶颈识别                          │
│           │                                                │
│           │ 使用机床分配作为输入                            │
│           ▼                                                │
│  ┌──────────────────┐                                      │
│  │ 【AGV智能体】    │                                      │
│  │ AGVCoordinator   │  - 物料路由规划                      │
│  │                  │  - AGV队列管理                       │
│  │  输出：物流方案  │  - 交通热点分析                      │
│  └────────┬─────────┘  - 缓冲策略设置                      │
│           │                                                │
│           │ 使用机床和AGV信息作为输入                       │
│           ▼                                                │
│  ┌──────────────────┐                                      │
│  │【机器人智能体】  │                                      │
│  │ RobotCellAgent   │  - 上下料任务分配                    │
│  │                  │  - 夹具切换规划                      │
│  │  输出：执行计划  │  - 检测策略制定                      │
│  └──────────────────┘  - 返工缓冲区设置                    │
│                                                             │
└─────────────────────────────────────────────────────────┘
```

## 核心实现特点

### 1. 会话接入后端

**会话创建流程**：
- 使用 UUID 生成全局唯一的会话 ID
- 通过 `POST /api/v1/tasks` 端点向后端创建会话
- 后端返回工作流 ID 用于追踪执行过程

```python
# 会话创建
session_id = str(uuid.uuid4())
response = requests.post(
    'http://localhost:8080/api/v1/tasks',
    json={
        "query": "初始化生产调度会话",
        "session_id": session_id,
        "context": {
            "workflow_type": "production_scheduling",
            "session_name": session_name
        },
        "mode": "simple"
    }
)
```

**会话信息保存**：
```json
{
  "session_id": "2e749e04-db21-475e-8fa3-58b275d9ee8e",
  "session_info": {
    "id": "2e749e04-db21-475e-8fa3-58b275d9ee8e",
    "name": "machining_schedule_1769665847",
    "workflow_id": "task-00000000-0000-0000-0000-000000000002-1769665848",
    "status": "created",
    "timestamp": "2026-01-29T13:50:48.639502"
  }
}
```

### 2. 三智能体任务提交

每个智能体都向后端提交任务，使用相同的会话 ID 确保连续性：

```python
payload = {
    "query": agent_prompt,              # 智能体的推理任务
    "session_id": session_id,           # 会话持续性
    "context": {
        "agent_type": self.agent_name,
        "agent_input": input_data,
        "timestamp": datetime.now().isoformat()
    },
    "mode": "simple"
}

response = requests.post(
    'http://localhost:8080/api/v1/tasks',
    json=payload,
    timeout=10
)
```

### 3. 协同过程追踪

系统记录每个智能体的执行步骤，形成完整的协同时间线：

```python
class ProductionSchedulingAgent:
    def __init__(self, agent_name: str, session_id: str):
        self.agent_name = agent_name
        self.session_id = session_id
        self.coordination_log = []  # 协同日志
    
    def log_coordination(self, message: str):
        """记录协同过程的每一步"""
        timestamp = datetime.now().isoformat()
        log_entry = {
            "timestamp": timestamp,
            "agent": self.agent_name,
            "message": message
        }
        self.coordination_log.append(log_entry)
```

## 执行流程

### 步骤 1：环境验证
```
✓ Python 版本: 3.12.10
✓ requests 已安装
✓ 后端服务正常
```

### 步骤 2：会话创建
```
会话 ID: 2e749e04-db21-475e-8fa3-58b275d9ee8e
工作流 ID: task-00000000-0000-0000-0000-000000000002-1769665848
```

### 步骤 3：机床智能体执行
```
【机床智能体】MachineToolAgent 开始执行...
├─ 初始化 MachineToolAgent
├─ 向后端提交任务
├─ 分析零件优先级和加工工序
├─ 零件排序完成: PART-004 -> PART-001 -> PART-005 -> PART-002 -> PART-003
├─ 机床分配: CNC-1(2件), CNC-2(2件), CNC-3(1件)
├─ 计算主轴利用率: 90.0%
└─ 执行完成，耗时 0.07 秒

输出内容：
  - part_count: 5
  - process_sequence: [PART-004, PART-001, ...]
  - machine_allocation: {cnc_1: [...], cnc_2: [...], cnc_3: [...]}
  - spindle_utilization: 0.90
  - estimated_cycle_hours: 9.0
```

### 步骤 4：AGV协调智能体执行（与机床协同）
```
【AGV智能体】AGVCoordinator 开始执行...
├─ 初始化 AGVCoordinator
├─ 向后端提交任务
├─ 分析机床分配需求，规划物料路由
├─ 路由分配: AGV-01 负责 库房->cnc_1
├─ 路由分配: AGV-02 负责 库房->cnc_2
├─ 共规划 2 条物料路由
├─ 分析交通热点和缓冲策略
└─ 执行完成，耗时 0.07 秒

协同展示：
  - 使用机床智能体的 machine_allocation 作为输入
  - 根据机床分配规划AGV路由
  - 确保物料能及时供应各个机床
```

### 步骤 5：机器人协调智能体执行（与前两个协同）
```
【机器人智能体】RobotCellAgent 开始执行...
├─ 初始化 RobotCellAgent
├─ 向后端提交任务
├─ 分析零件加工流程，规划机器人任务
├─ 任务分配: ROBOT-01 负责 PART-001 的上下料
├─ 任务分配: ROBOT-02 负责 PART-002 的上下料
├─ 共分配 2 个上下料任务
├─ 计算夹具切换次数和抽检策略
└─ 执行完成，耗时 0.14 秒

协同展示：
  - 使用机床和AGV信息规划机器人任务
  - 与整个生产流程同步
  - 确保机器人能及时完成上下料
```

## 协同过程时间线

系统记录了26条协同事件，按时间顺序排列：

```
 1. [13:50:48.641] 机床智能体: 初始化 MachineToolAgent
 2. [13:50:48.641] 机床智能体: 向后端提交任务
 3. [13:50:48.711] 机床智能体: 后端任务执行成功
 4. [13:50:48.712] 机床智能体: 分析零件优先级
 5. [13:50:48.712] 机床智能体: 零件排序完成
 6. [13:50:48.712] 机床智能体: 机床分配完成
 7. [13:50:48.712] 机床智能体: 计算主轴利用率
 8. [13:50:48.712] 机床智能体: 执行完成

 9. [13:50:48.714] AGV智能体: 初始化 AGVCoordinator
10. [13:50:48.714] AGV智能体: 向后端提交任务
11. [13:50:48.779] AGV智能体: 后端任务执行成功
12. [13:50:48.780] AGV智能体: 分析机床分配
13. [13:50:48.780] AGV智能体: 路由分配 AGV-01
14. [13:50:48.780] AGV智能体: 路由分配 AGV-02
15. [13:50:48.780] AGV智能体: 共规划 2 条路由
16. [13:50:48.781] AGV智能体: 分析交通热点
17. [13:50:48.781] AGV智能体: 执行完成

18. [13:50:48.783] 机器人智能体: 初始化 RobotCellAgent
19. [13:50:48.783] 机器人智能体: 向后端提交任务
20. [13:50:48.917] 机器人智能体: 后端任务执行成功
21. [13:50:48.918] 机器人智能体: 分析零件加工流程
22. [13:50:48.918] 机器人智能体: 任务分配 ROBOT-01
23. [13:50:48.918] 机器人智能体: 任务分配 ROBOT-02
24. [13:50:48.919] 机器人智能体: 共分配 2 个任务
25. [13:50:48.919] 机器人智能体: 计算夹具切换
26. [13:50:48.920] 机器人智能体: 执行完成
```

## 关键性能指标

| 指标 | 数值 | 说明 |
|------|------|------|
| 结构件数量 | 5 件 | 待加工的结构件总数 |
| 机床类型 | 3 台 | CNC-1, CNC-2, CNC-3 |
| 主轴利用率 | 90.0% | 机床的平均利用效率 |
| 预计加工时长 | 9.0 小时 | 总周期时间 |
| AGV数量 | 2 台 | AGV-01, AGV-02 |
| 物料路由 | 2 条 | 库房→机床, 机床→检测 |
| AGV排队时间 | 12 分钟 | 物料等待时间 |
| 机器人数量 | 2 台 | ROBOT-01, ROBOT-02 |
| 夹具切换次数 | 3 次 | 生产过程中的夹具变更 |
| 机器人抽检率 | 10.0% | 检测比例 |
| 总执行时间 | 0.28 秒 | 三智能体完整执行时间 |

## 文件输出

### 1. JSON结果文件
**文件名**: `schedule_result_1769665848.json`

包含内容：
- 会话信息（会话ID、工作流ID、创建时间）
- 机床排产结果
- AGV物流协调结果
- 机器人执行计划
- 完整的协同时间线（26条事件）
- 执行总结和协同过程详情

### 2. 会话追踪
可通过以下接口查询：
- **Temporal UI**: http://localhost:8088 - 查看工作流执行详情
- **Grafana**: http://localhost:3030 - 查看性能指标
- **Gateway API**: http://localhost:8080/api/docs - API文档

## 协同优势

1. **会话持续性**：三个智能体共享同一个会话ID，在后端形成完整的执行链条
2. **输入输出关联**：后续智能体使用前序智能体的输出作为输入
3. **实时追踪**：通过协同日志记录每个步骤，便于监控和调试
4. **分布式执行**：智能体在后端独立执行，通过会话ID关联
5. **结果聚合**：所有协同过程记录在同一个JSON文件中

## 使用示例

### 运行完整演示
```bash
python production_scheduler_demo.py
```

### 验证会话接入
```bash
python verify_session_backend.py
```

### 查看生成的结果
```bash
# 显示最新的JSON结果
Get-Content schedule_result_*.json -Last 1
```

## 后续增强方向

1. **动态重调度**：根据实时反馈动态调整生产计划
2. **多轮协同**：支持智能体之间的多轮对话和迭代优化
3. **实时监控**：集成Temporal和Grafana的实时信息到协同过程中
4. **异常处理**：当某个步骤失败时，触发自动调度调整
5. **集群管理**：扩展到多个车间、多个生产线的全局优化

## 总结

本系统成功实现了：

✅ 会话接入Shannon后端，使用 `POST /api/v1/tasks` API  
✅ 三个具身智能体（机床、AGV、机器人）的顺序执行  
✅ 完整的协同过程追踪，26条时间戳事件  
✅ 每个智能体使用前序结果作为输入，体现协同  
✅ 结果持久化保存为JSON格式，便于后续分析  

这为复杂的多智能体生产调度系统提供了可靠的基础。
